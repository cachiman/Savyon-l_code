#!/usr/bin/env bash
# LICENSE: unlicense. This is free and unencumbered software released into the public domain.
# see unlicense.org for full license
#
# source this command if you want to have it change directories for you

RED=$(tput setaf 1)
CLEAR=$(tput sgr0)
VERBOSE=

function usage {
    cat <<EOF
worktree [-v] <branch name>

create a git worktree with <branch name>. Will create a worktree if one isn't
found that matches the given name.

Will copy over any .env, .envrc, or .tool-versions files to the new worktree
EOF
    kill -INT $$
}

function die {
    printf '%s%s%s\n' "$RED" "$1" "$CLEAR"
    # exit the script, but if it was sourced, don't kill the shell
    kill -INT $$
}

# Create a worktree from a given branchname, in exactly the way I like it.
function worktree {
    if [ -z "$1" ]; then
        echo "usage: worktree <branch name>"
        return 1
    fi

    if [ -n "$VERBOSE" ]; then
        set -x
    fi
    branchname="$1"

    # Replace slashes with underscores. If there's no slash, dirname will equal
    # branchname. So "alu/something-other" becomes "alu_something-other", but
    # "quick-fix" stays unchanged
    # https://www.tldp.org/LDP/abs/html/parameter-substitution.html
    dirname=${branchname//\//_}

    # pull the most recent version of the remote
    git pull

    # if the branch name already exists, we want to check it out. Otherwise,
    # create a new branch. I'm sure there's probably a way to do that in one
    # command, but I'm done fiddling with git at this point
    #
    # As far as I can tell, we have to check locally and remotely separately if
    # we want to be accurate. See https://stackoverflow.com/a/75040377 for the
    # reasoning here. Also this has some caveats, but probably works well
    # enough :shrug:
    #
    # if the branch exists locally:
    if git for-each-ref --format='%(refname:lstrip=2)' refs/heads | grep -E "^$branchname$" > /dev/null 2>&1; then
        if ! git worktree add "../$dirname" "$branchname"; then
            die "failed to create git worktree $branchname"
        fi
    # if the branch exists on a remote:
    elif git for-each-ref --format='%(refname:lstrip=3)' refs/remotes/origin | grep -E "^$branchname$" > /dev/null 2>&1; then
        if ! git worktree add "../$dirname" "$branchname"; then
            die "failed to create git worktree $branchname"
        fi
    else
        # otherwise, create a new branch
        if ! git worktree add -b "$branchname" "../$dirname"; then
            die "failed to create git worktree $branchname"
        fi
    fi

    # copy some useful untracked files into the new worktree
    find . \( -name .envrc \
        -or -name .env \
        -or -name .tool-versions \) \
        -exec cp {} ../"$dirname"/{} \;

    if [ -f "../$dirname/.envrc" ]; then
        direnv allow "../$dirname"
    fi

    # now change to the new tree and enable the root envrc if present
    cd "../$dirname" || return
    printf "%screated worktree %s%s\n" "$RED" "../$dirname" "$CLEAR"

}

while true; do
    case $1 in
        help | -h | --help)
            usage
            ;;
        -v | --verbose)
            VERBOSE=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

worktree "$@"
